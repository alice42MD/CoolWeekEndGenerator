
// import { WiRain, WiCloudy, WiDaySunny, WiSnow, WiStormShowers } from "react-icons/wi";
// import { FC, useEffect, useState } from "react";
// import { AutocompleteAddress } from "./Map";
// export interface Coordinates {
//   lon: number;
//   lat: number;
// }

// interface WeatherEntryProps {
//   weather: Weather;
//   location: string;
//   forecastIsOn: boolean
// }

// interface LocationTableProps {
//   locations: WeatherLocation[];
//   current: WeatherLocation | null;
//   onSelect: (location: WeatherLocation) => void;
// }


// interface WeatherLocation {
//   coord: Coordinates;
//   id: number;
//   name: string;
// }

// interface WeatherConditions {
//   id: number;
//   main: string;
//   description: string;
//   icon: string;
// }

// interface MainWeatherData {
//   temp: number;
//   feels_like: number;
//   temp_min: number;
//   temp_max: number;
//   pressure: number;
//   humidity: number;
// }


// interface Weather {
//   weather: WeatherConditions[];
//   main: MainWeatherData;
//   dt: number;
// }

// interface LocationSearchProps {
//   onSearch: (search: string) => void;
// }
// //

// // function convertUnixTimeToDate (unixUtc: number): Date {
// //   return new Date(unixUtc * 1000);
// // }


// export const LocationSearch: FC<LocationSearchProps> = ({ onSearch }) => {
//   const [locationSearch, setLocationSearch] = useState('');
//   const disableSearch = locationSearch.trim() === '';

//   const addLocation = () => {
//     onSearch(locationSearch);
//     setLocationSearch('');
//   };

//   return (
//     <div>
//       <label>

//         <AutocompleteAddress
//           setCustomLocation={() => { }}
//           setAddress={() => { }}
//           setSelectedOption={() => { }}
//         />
//       </label>
//       <button className="btn btn-primary"
//         onClick={addLocation} disabled={disableSearch}>Search
//       </button>
//     </div >
//   );
// }

// const LocationTable: FC<LocationTableProps> = ({ locations, onSelect, current }) =>
//   <div>

//     {locations.map(location =>
//       <div key={location.id}
//         className={current?.id === location.id ? 'table-primary' : ''}
//         onClick={() => onSelect(location)}>
//         <div>{location.name}</div>
//       </div>
//     )}

//   </div>;


// const WeatherEntry: FC<WeatherEntryProps> = ({ weather, location, forecastIsOn }) => {
//   function getIconUrl (code: string) {

//     const icons = [
//       {
//         type: 'Rain', icon: <WiRain />
//       },
//       {
//         type: 'Clouds', icon: <WiCloudy />
//       },
//       {
//         type: 'Thunderstorm', icon: <WiStormShowers />
//       },
//       {
//         type: 'Drizzle', icon: <WiRain />
//       },
//       {
//         type: 'Snow', icon: <WiSnow />
//       },
//       {
//         type: 'Clear', icon: <WiDaySunny />
//       }
//     ]

//     return icons.find(a => a.type === code)
//   }
//   return (

//     <div
//       style={{
//         'display': 'flex',
//         'color': 'white',
//         textAlign: 'center'

//       }}
//     >

//       <div style={{
//         'display': 'flex',
//         'flexDirection': 'column',
//         justifyContent: 'center',

//       }}>
//         <div style={{ 'textAlign': 'center' }}>{location}</div>
//         <div style={{ 'textAlign': 'center' }}>{weather.main.temp}°C</div>
//         {!forecastIsOn && <div>
//           <div style={{ 'textAlign': 'center' }}>({weather.main.temp_min}°C / {weather.main.temp_max}°C)</div>
//         </div>}
//       </div>
//       <div style={{
//         'display': 'flex',
//         'flexDirection': 'column',
//         justifyContent: 'center',

//       }}>

//         <div style={{
//           'display': 'flex',
//           'justifyContent': 'space-around'
//         }}>
//           {
//             weather.weather.map(condition => {
//               console.log('condition', condition)

//               return <div key={condition.id}>
//                 {getIconUrl(condition.main)?.icon}
//                 <div>{condition.description}</div>
//               </div>
//             })
//           }
//         </div>
//         {!forecastIsOn && <div style={{ 'textAlign': 'center' }}>Humidity: {weather.main.humidity}%</div>}
//       </div>
//     </div>


//   )
// }

// interface CustomLocation {
//   lat: number;
//   lng: number;
// }


// interface AllMapProps {
//   location: CustomLocation
//   forecastIsOn: boolean
// }

// const WeatherComponent: React.FC<AllMapProps> = ({ location, forecastIsOn = false }: { location: CustomLocation, forecastIsOn: boolean }) => {
//   const [weather, setWeather] = useState<Weather | null>(null);
//   const [locations, setLocations] = useState<WeatherLocation[]>([]);
//   // const [error, setError] = useState('');
//   // const [warning, setWarning] = useState('');

//   const [currentLocation, setCurrentLocation] = useState<WeatherLocation | null>(null);
//   const [forecast, setForecast] = useState<Weather[] | null>(null);

//   useEffect(() => {
//     (async function () {
//       if (currentLocation) {
//         const [weather, forecast] = await Promise.all([
//           readWeather(currentLocation.id),
//           readForecast(currentLocation.id)
//         ]);
//         setWeather(weather);
//         setForecast(forecast);
//       }
//     })()
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [location]);


//   useEffect(() => {
//     (async function () {
//       if (currentLocation) {
//         const [weather, forecast] = await Promise.all([
//           readWeather(currentLocation.id),
//           readForecast(currentLocation.id)
//         ]);
//         setWeather(weather);
//         setForecast(forecast);
//       }
//     })()
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [currentLocation]);



//   useEffect(() => {
//     (async function () {
//       if (location) {
//         const c = await a(location)
//         console.log('TEST B', c)
//         setWeather(c)
//         setCurrentLocation({
//           coord: c.coords,
//           id: c.id,
//           name: c.name
//         })
//       }
//     })()
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [location]);

//   const a = async (location: CustomLocation) => {
//     const b = await fetch(`${server}/weather?lat=${location.lat}&lon=${location.lng}&${keyQuery}`)
//     return await b.json();
//   }

//   const key: string = "9bb2813700a6e5208a2991e5c9f609db" as string;
//   if (key === undefined) {
//     throw new Error('No Open Weather API Key defined - ensure you set a variable called REACT_APP_OPEN_WEATHER_API_KEY')
//   }

//   const keyQuery = `appid=${key}`
//   const server = 'http://api.openweathermap.org/data/2.5';

//   async function searchLocation (term: string): Promise<WeatherLocation | undefined> {
//     const result = await fetch(`${server}/weather?q=${term}&${keyQuery}&lang=fr`);

//     if (result.status === 404) return undefined;
//     if (result.status !== 200) throw new Error('Failed to read location data');

//     return await result.json();
//   }


//   async function readForecast (locationId: number): Promise<Weather[]> {
//     const forecast = await fetch(`${server}/forecast?id=${locationId}&${keyQuery}&units=metric&cnt=8&lang=fr`);

//     if (forecast.status !== 200) throw new Error('Failed to read location data');

//     return (await forecast.json()).list;
//   }

//   async function readWeather (locationId: number): Promise<Weather> {
//     const current = await fetch(`${server}/weather?id=${locationId}&${keyQuery}&units=metric&lang=fr`);

//     if (current.status !== 200) throw new Error('Failed to read location data');

//     return await current.json();
//   }

//   const resetAlerts = () => {
//     // setError('');
//     // setWarning('');
//   }

//   const m_per_deg_lat = 111132.954 - 559.822 * Math.cos(2 * location.lat + 1.175 * Math.cos(4 * location.lat));
//   const m_per_deg_lon = 111132.954 * Math.cos(location.lat);


//   console.log(' m_per_deg_lat', m_per_deg_lat, ' m_per_deg_lon', m_per_deg_lon)
//   let addLocation = async (term: string) => {
//     resetAlerts();
//     const location = await searchLocation(term);

//     if (!location) {
//       // setError(`No location found called '${term}'`);
//     } else if (locations.find(item => item.id === location.id)) {
//       // setWarning(`Location '${term}' is already in the list.`);
//     } else {
//       setLocations([location, ...locations]);
//       setCurrentLocation(location)
//     }
//   };


//   if (forecastIsOn) return (
//     currentLocation && weather && forecast &&

//     <div
//       style={{
//         'color': 'white', textAlign: 'center'
//       }}
//     >
//       <h2>Forecast</h2>
//       <LocationSearch onSearch={addLocation} />
//       <LocationTable
//         locations={locations}
//         current={currentLocation}
//         onSelect={location => setCurrentLocation(location)} />
//       <div>
//         <ol >
//           {forecast.map(timePoint =>

//             <li key={timePoint.dt}>
//               <WeatherEntry weather={timePoint} location={currentLocation.name} forecastIsOn={forecastIsOn} />
//               <br />
//             </li>


//           )}
//         </ol>
//       </div>

//     </div>
//   )
//   return (
//     <>
//       {
//         currentLocation && weather && <>
//           <WeatherEntry weather={weather} location={currentLocation.name} forecastIsOn={forecastIsOn} />
//         </>
//       }

//     </ >

//   );
// }

// export default WeatherComponent